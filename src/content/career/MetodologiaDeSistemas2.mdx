---
title: Metodología De Sistemas 2
author: Felipe Arce
description: Apuntes de Metodología de Sistemas 2 que profundizan en análisis avanzado, diseño de sistemas complejos y gestión de proyectos de software empresarial.
image:
  url: '/ApunteMetodologiaDeSistemas2.png'
  alt: 'Apunte de Metodología de Sistemas 2'
pubDate: 2025-08-30
tags: ['Apuntes', 'MetodologiaDeSistemas', 'CuartoCuatrimestre']
totalTimeClass: 64
totalExam: 8
totalTime: 72
order: 17
professor: Por definir
---

<div className="text-fixed">
### Metodología de Sistemas 2

#### Análisis y Diseño Avanzado de Sistemas

Esta materia continúa con los conceptos introducidos en Metodología de Sistemas 1, profundizando en técnicas avanzadas de análisis y diseño de sistemas de información empresariales.

### Objetivos del Curso

- Dominar metodologías ágiles de desarrollo
- Gestionar proyectos de software complejos
- Aplicar técnicas de análisis de requerimientos avanzadas
- Diseñar arquitecturas de sistemas escalables

### Clase 1: Patrones de Diseño

#### ¿Qué es un Patrón de Diseño?

Un patrón de diseño de software es una solución probada y reutilizable para un problema recurrente en el diseño de sistemas orientados a objetos.

**Definición formal:** "Un patrón de diseño describe un problema que ocurre una y otra vez en nuestro entorno, y luego describe la esencia de su solución, de forma que puede ser utilizada muchas veces."

#### Características principales

1. **Reutilizables**: aplicables a múltiples problemas similares.
2. **Abstracciones de soluciones**: no son código específico, sino esquemas o ideas aplicables.
3. **Documentados**: tienen una estructura estándar que facilita su comprensión y aplicación.

#### Estructura típica de un patrón

- **Nombre**: etiqueta clara que lo identifica (ej.: Singleton).
- **Problema**: describe la situación que da origen al patrón.
- **Solución**: el enfoque general propuesto para resolver el problema.
- **Consecuencias**: efectos positivos y posibles limitaciones del patrón.

#### Clasificación de Patrones de Diseño

Los patrones de diseño se clasifican en tres categorías principales:

##### 1. Patrones Creacionales

Estos patrones proporcionan mecanismos de creación de objetos que incrementan la flexibilidad y la reutilización del código existente.

##### 2. Patrones Estructurales

Estos patrones explican cómo ensamblar objetos y clases en estructuras más grandes, mientras se mantiene la flexibilidad y eficiencia de la estructura.

##### 3. Patrones de Comportamiento

Estos patrones tratan con algoritmos y la asignación de responsabilidades entre objetos.

#### ¿Por qué son importantes los Patrones de Diseño?

**Ventajas:**
- Mejoran la calidad y mantenimiento del código.
- Promueven la reutilización y coherencia en el diseño.
- Ayudan a resolver problemas comunes con soluciones bien comprendidas.
- Facilitan el trabajo en equipo al estandarizar enfoques.

**Relación con el desarrollo profesional:**
- Muchos problemas reales del desarrollo de software ya han sido resueltos por otros equipos.
- Conocer patrones permite evitar "reinventar la rueda".
- Son ampliamente utilizados en frameworks, bibliotecas y arquitecturas modernas.

---

### Clase 2: Patrones Creacionales

#### ¿Qué son los Patrones Creacionales?

Los patrones creacionales abordan la manera en la que se crean los objetos en un sistema. Su propósito es desacoplar el proceso de creación del objeto del código que lo utiliza, brindando mayor flexibilidad, control y reutilización en la arquitectura del software.

**Beneficios principales:**
- Ocultan los detalles de instanciación de los objetos.
- Permiten crear estructuras de objetos más flexibles y dinámicas.
- Facilitan la implementación de arquitecturas orientadas a la expansión (extensibles).

#### Singleton (Instancia única)

Singleton asegura que una clase tenga una única instancia y proporciona un punto de acceso global a ella.

**Casos de uso comunes:**
- Conexiones a base de datos.
- Gestión de logs o configuración de la aplicación.
- Sistemas de impresión o recursos compartidos.

##### Singleton - Problema

El patrón Singleton resuelve dos problemas al mismo tiempo, vulnerando el Principio de responsabilidad única:

**1) Garantizar que una clase tenga una única instancia.**

¿Por qué querría alguien controlar cuántas instancias tiene una clase? El motivo más habitual es controlar el acceso a algún recurso compartido, por ejemplo, una base de datos o un archivo.

- Funciona así: imagina que has creado un objeto y al cabo de un tiempo decides crear otro nuevo. En lugar de recibir un objeto nuevo, obtendrás el que ya habías creado.
- Ten en cuenta que este comportamiento es imposible de implementar con un constructor normal, ya que una llamada al constructor siempre debe devolver un nuevo objeto por diseño.

Puede ser que los clientes ni siquiera se den cuenta de que trabajan con el mismo objeto todo el tiempo.

Hoy en día el patrón Singleton se ha popularizado tanto que la gente suele llamar singleton a cualquier patrón, incluso si solo resuelve uno de los problemas antes mencionados.

**2) Proporcionar un punto de acceso global a dicha instancia.**

¿Recuerdas esas variables globales que utilizaste para almacenar objetos esenciales? Aunque son muy útiles, también son poco seguras, ya que cualquier código podría sobrescribir el contenido de esas variables y descomponer la aplicación.

Al igual que una variable global, el patrón Singleton nos permite acceder a un objeto desde cualquier parte del programa. No obstante, también evita que otro código sobreescriba esa instancia.

Este problema tiene otra cara: no queremos que el código que resuelve el primer problema se encuentre disperso por todo el programa. Es mucho más conveniente tenerlo dentro de una clase, sobre todo si el resto del código ya depende de ella.

##### Singleton - Solución

Todas las implementaciones del patrón Singleton tienen estos dos pasos en común:

- **Hacer privado el constructor por defecto** para evitar que otros objetos utilicen el operador `new` con la clase Singleton.
- **Crear un método de creación estático** que actúe como constructor. Este método invoca al constructor privado para crear un objeto y lo guarda en un campo estático. Las siguientes llamadas a este método devuelven el objeto almacenado en caché.

Si tu código tiene acceso a la clase Singleton, podrá invocar su método estático. De esta manera, cada vez que se invoque este método, siempre se devolverá el mismo objeto.

**Analogía en el mundo real:**

El gobierno es un ejemplo excelente del patrón Singleton. Un país sólo puede tener un gobierno oficial. Independientemente de las identidades personales de los individuos que forman el gobierno, el título "Gobierno de X" es un punto de acceso global que identifica al grupo de personas a cargo.

##### Singleton - Estructura

1. La clase Singleton declara el método estático `getInstance` que devuelve la misma instancia de su propia clase.
2. El constructor del Singleton debe ocultarse del código cliente. La llamada al método `getInstance` debe ser la única manera de obtener el objeto de Singleton.

##### Singleton - Ventajas y desventajas

**Ventajas:**
- Control completo sobre la instancia única.
- Facilita el acceso centralizado a ciertos recursos.

**Desventajas:**
- Puede ocultar dependencias.
- Dificulta las pruebas unitarias si no se gestiona correctamente.

#### Factory Method (Método fábrica, Constructor virtual)

Factory Method es un patrón de diseño creacional que proporciona una interfaz para crear objetos en una superclase, mientras permite a las subclases alterar el tipo de objetos que se crearán.

**Propósito:**
- Define una interfaz para crear un objeto, pero permite que las subclases decidan qué clase instanciar.
- Encapsula la creación de objetos dentro de un método.

**Ventajas:**
- Aumenta la flexibilidad al permitir instanciar distintas clases según el contexto.
- Se integra fácilmente con el principio de "abierto/cerrado" (Open/Closed).

> **Principio Abierto/Cerrado:** Es una regla de diseño de software que establece que las entidades de software (clases, módulos, funciones) deben estar abiertas a la extensión, pero cerradas a la modificación. Esto significa que se puede añadir nuevo comportamiento o funcionalidad al código sin tener que modificar el código existente, lo que promueve sistemas más flexibles, mantenibles y adaptables. Se logra principalmente a través del uso de abstracciones, interfaces y herencia.

##### Factory Method - Problema

Imagina que estás creando una aplicación de gestión logística. La primera versión de tu aplicación sólo es capaz de manejar el transporte en camión, por lo que la mayor parte de tu código se encuentra dentro de la clase `Camión`.

Al cabo de un tiempo, tu aplicación se vuelve bastante popular. Cada día recibes decenas de peticiones de empresas de transporte marítimo para que incorpores la logística por mar a la aplicación.

Añadir una nueva clase al programa no es tan sencillo si el resto del código ya está acoplado a clases existentes. En este momento, la mayor parte de tu código está acoplado a la clase `Camión`. Para añadir barcos a la aplicación habría que hacer cambios en toda la base del código. Además, si más tarde decides añadir otro tipo de transporte a la aplicación, probablemente tendrás que volver a hacer todos estos cambios.

Al final acabarás con un código bastante sucio, plagado de condicionales que cambian el comportamiento de la aplicación dependiendo de la clase de los objetos de transporte.

##### Factory Method - Solución

El patrón Factory Method sugiere que, en lugar de llamar al operador `new` para construir objetos directamente, se invoque a un método fábrica (`create`) especial. No te preocupes: los objetos se siguen creando a través del operador `new`, pero se invocan desde el método fábrica. Los objetos devueltos por el método fábrica a menudo se denominan **productos**.

Las subclases pueden alterar la clase de los objetos devueltos por el método fábrica.

A simple vista, puede parecer que este cambio no tiene sentido, ya que tan solo hemos cambiado el lugar desde donde invocamos al constructor. Sin embargo, piensa en esto: ahora puedes sobrescribir el método fábrica en una subclase y cambiar la clase de los productos creados por el método.

No obstante, hay una pequeña limitación: las subclases sólo pueden devolver productos de distintos tipos si dichos productos tienen una clase base o interfaz común. Además, el método fábrica en la clase base debe tener su tipo de retorno declarado como dicha interfaz.

**Todos los productos deben seguir la misma interfaz.**

Por ejemplo, tanto la clase `Camión` como la clase `Barco` deben implementar la interfaz `Transporte`, que declara un método llamado `entrega`. Cada clase implementa este método de forma diferente: los camiones entregan su carga por tierra, mientras que los barcos lo hacen por mar.

El método fábrica dentro de la clase `LogísticaTerrestre` devuelve objetos de tipo camión, mientras que el método fábrica de la clase `LogísticaMarítima` devuelve barcos.

Siempre y cuando todas las clases de producto implementen una interfaz común, podrás pasar sus objetos al código cliente sin descomponerlo.

El código que utiliza el método fábrica (a menudo denominado **código cliente**) no encuentra diferencias entre los productos devueltos por varias subclases, y trata a todos los productos como la clase abstracta `Transporte`. El cliente sabe que todos los objetos de transporte deben tener el método `entrega`, pero no necesita saber cómo funciona exactamente.

##### Factory Method - Estructura

1. **El Producto** declara la interfaz, que es común a todos los objetos que puede producir la clase creadora y sus subclases.

2. **Los Productos Concretos** son distintas implementaciones de la interfaz de producto.

3. **La clase Creadora** declara el método fábrica que devuelve nuevos objetos de producto. Es importante que el tipo de retorno de este método coincida con la interfaz de producto. Puedes declarar el patrón Factory Method como abstracto para forzar a todas las subclases a implementar sus propias versiones del método. Como alternativa, el método fábrica base puede devolver algún tipo de producto por defecto.

4. **Los Creadores Concretos** sobrescriben el Factory Method base, de modo que devuelva un tipo diferente de producto. Observa que el método fábrica no tiene que crear nuevas instancias todo el tiempo. También puede devolver objetos existentes de una memoria caché, una agrupación de objetos, u otra fuente.

> **Nota:** `doStuff()` es un nombre genérico de una función o método en diseño de software que indica que la función debe "hacer algo"; no es un término técnico específico sino una forma de indicar que esa parte del código tiene una tarea que realizar sin especificar cuál es esa tarea. Su uso es común como un marcador de posición o un ejemplo de código, donde el desarrollador debe reemplazarlo con la implementación real de la funcionalidad deseada.

##### Factory Method - ¿Cuándo se puede aplicar?

✓ Cuando no conozcas de antemano las dependencias y los tipos exactos de los objetos con los que deba funcionar tu código.

✓ Cuando quieras ofrecer a los usuarios de tu biblioteca o framework, una forma de extender sus componentes internos.

✓ Cuando quieras ahorrar recursos del sistema mediante la reutilización de objetos existentes en lugar de reconstruirlos cada vez.

#### Abstract Factory (Fábrica Abstracta)

##### Abstract Factory - Solución

Lo primero que sugiere el patrón Abstract Factory es que declaremos de forma explícita interfaces para cada producto diferente de la familia de productos (por ejemplo, silla, sofá o mesilla). Después podemos hacer que todas las variantes de los productos sigan esas interfaces. Por ejemplo, todas las variantes de silla pueden implementar la interfaz `Silla`, así como todas las variantes de mesilla pueden implementar la interfaz `Mesilla`, y así sucesivamente.

**Todas las variantes del mismo objeto deben moverse a una única jerarquía de clase.**

El siguiente paso consiste en declarar la **Fábrica abstracta**: una interfaz con una lista de métodos de creación para todos los productos que son parte de la familia de productos (por ejemplo, `crearSilla`, `crearSofá` y `crearMesilla`). Estos métodos deben devolver productos abstractos representados por las interfaces que extrajimos previamente: `Silla`, `Sofá`, `Mesilla`, etc.

Ahora bien, ¿qué hay de las variantes de los productos? Para cada variante de una familia de productos, creamos una clase de fábrica independiente basada en la interfaz `FábricaAbstracta`. Una fábrica es una clase que devuelve productos de un tipo particular. Por ejemplo, la `FábricadeMueblesModernos` sólo puede crear objetos modernos.

El código cliente tiene que funcionar con fábricas y productos a través de sus respectivas interfaces abstractas. Esto nos permite cambiar el tipo de fábrica que pasamos al código cliente, así como la variante del producto que recibe el código cliente, sin descomponer el propio código cliente.

Al cliente no le debe importar la clase concreta de la fábrica con la que funciona. Ya sea un modelo moderno o una silla de estilo victoriano, el cliente debe tratar a todas las sillas del mismo modo, utilizando la interfaz abstracta `Silla`. Con este sistema, lo único que sabe el cliente sobre la silla es que implementa de algún modo el método `sentarse`. Además, sea cual sea la variante de silla devuelta, siempre combinará con el tipo de sofá o mesilla producida por el mismo objeto de fábrica.

##### Abstract Factory - Estructura

1. **Los Productos Abstractos** declaran interfaces para un grupo de productos diferentes pero relacionados que forman una familia de productos.

2. **Los Productos Concretos** son implementaciones distintas de productos abstractos agrupados por variantes. Cada producto abstracto (silla/sofá) debe implementarse en todas las variantes dadas (victoriano/moderno).

3. **La interfaz Fábrica Abstracta** declara un grupo de métodos para crear cada uno de los productos abstractos.

4. **Las Fábricas Concretas** implementan métodos de creación de la fábrica abstracta. Cada fábrica concreta se corresponde con una variante específica de los productos y crea tan solo dichas variantes de los productos.

5. Aunque las fábricas concretas instancian productos concretos, las firmas de sus métodos de creación deben devolver los productos abstractos correspondientes. De este modo, el código cliente que utiliza una fábrica no se acopla a la variante específica del producto que obtiene de una fábrica. **El Cliente** puede funcionar con cualquier variante fábrica/producto concreta, siempre y cuando se comunique con sus objetos a través de interfaces abstractas.

##### Abstract Factory - ¿Cuándo se puede aplicar?

✓ Cuando tu código deba funcionar con varias familias de productos relacionados, pero no desees que dependa de las clases concretas de esos productos, ya que puede ser que no los conozcas de antemano o sencillamente quieras permitir una futura extensibilidad.

✓ Cuando tengas una clase con un grupo de métodos de fábrica que nublen su responsabilidad principal.

#### Builder (Constructor)

Builder es un patrón de diseño creacional que nos permite construir objetos complejos paso a paso. El patrón nos permite producir distintos tipos y representaciones de un objeto empleando el mismo código de construcción.

##### Builder - Problema

Imagina un objeto complejo que requiere una inicialización laboriosa, paso a paso, de muchos campos y objetos anidados. Normalmente, este código de inicialización está sepultado dentro de un monstruoso constructor con una gran cantidad de parámetros. O, peor aún: disperso por todo el código cliente.

Crear una subclase por cada configuración posible de un objeto puede complicar demasiado el programa. Por ejemplo, pensemos en cómo crear un objeto `Casa`. Para construir una casa sencilla, debemos construir cuatro paredes y un piso, así como instalar una puerta, colocar un par de ventanas y ponerle un tejado. Pero ¿qué pasa si quieres una casa más grande y luminosa, con un jardín y otros extras (como sistema de calefacción, instalación de fontanería y cableado eléctrico)?

La solución más sencilla es extender la clase base `Casa` y crear un grupo de subclases que cubran todas las combinaciones posibles de los parámetros. Pero, en cualquier caso, acabarás con una cantidad considerable de subclases. Cualquier parámetro nuevo, como el estilo del porche, exigirá que incrementes esta jerarquía aún más.

Existe otra posibilidad que no implica generar subclases. Puedes crear un enorme constructor dentro de la clase base `Casa` con todos los parámetros posibles para controlar el objeto casa. Aunque es cierto que esta solución elimina la necesidad de las subclases, genera otro problema.

Un constructor con un montón de parámetros tiene su inconveniente: no todos los parámetros son necesarios todo el tiempo. En la mayoría de los casos, gran parte de los parámetros no se utilizará, lo que provocará que las llamadas al constructor sean bastante feas. Por ejemplo, solo una pequeña parte de las casas tiene piscina, por lo que los parámetros relacionados con piscinas serán inútiles en nueve de cada diez casos.

##### Builder - Solución

El patrón Builder sugiere que saques el código de construcción del objeto de su propia clase y lo coloques dentro de objetos independientes llamados **constructores**. El patrón organiza la construcción de objetos en una serie de pasos (`construirParedes`, `construirPuerta`, etc.). Para crear un objeto, se ejecuta una serie de estos pasos en un objeto constructor.

Puede ser que algunos pasos de la construcción necesiten una implementación diferente cuando tengamos que construir distintas representaciones del producto. Por ejemplo, las paredes de una cabaña pueden ser de madera, pero las paredes de un castillo tienen que ser de piedra.

> **El patrón Builder te permite construir objetos complejos paso a paso. El patrón Builder no permite a otros objetos acceder al producto mientras se construye.**

En este caso, podemos crear varias clases constructoras distintas que implementen la misma serie de pasos de construcción, pero de forma diferente. Entonces podemos utilizar estos constructores en el proceso de construcción (por ejemplo, una serie ordenada de llamadas a los pasos de construcción) para producir distintos tipos de objetos.

Los distintos constructores ejecutan la misma tarea de formas distintas. Por ejemplo, imagina un constructor que construye todo de madera y vidrio, otro que construye todo con piedra y hierro y un tercero que utiliza oro y diamantes. Al invocar la misma serie de pasos, obtenemos una casa normal del primer constructor, un pequeño castillo del segundo y un palacio del tercero. Sin embargo, esto sólo funcionaría si el código cliente que invoca los pasos de construcción es capaz de interactuar con los constructores mediante una interfaz común.

##### Builder - Estructura

1. **La interfaz Constructora** declara pasos de construcción de producto que todos los tipos de objetos constructores tienen en común.

2. **Los Constructores Concretos** ofrecen distintas implementaciones de los pasos de construcción. Los constructores concretos pueden crear productos que no siguen la interfaz común.

3. **Los Productos** son los objetos resultantes. Los productos construidos por distintos objetos constructores no tienen que pertenecer a la misma jerarquía de clases o interfaz.

4. **La clase Directora** define el orden en el que se invocarán los pasos de construcción, por lo que puedes crear y reutilizar configuraciones específicas de los productos.

5. **El Cliente** debe asociar uno de los objetos constructores con la clase directora. Normalmente, se hace una sola vez mediante los parámetros del constructor de la clase directora, que utiliza el objeto constructor para el resto de la construcción.

##### Builder - ¿Cuándo se puede aplicar?

✓ Utiliza el patrón Builder para evitar un "constructor telescópico". Cuando tengas un constructor con diez parámetros opcionales. Invocar a semejante bestia es poco práctico.

✓ Cuando quieras que el código sea capaz de crear distintas representaciones de ciertos productos (por ejemplo, casas de piedra y madera).




---

### Clase 3: Patrones Estructurales

#### Fundamentos de los Patrones Estructurales

Estos patrones explican cómo ensamblar objetos y clases en estructuras más grandes, mientras se mantiene la flexibilidad y eficiencia de la estructura. Los patrones estructurales se enfocan en cómo se organizan y componen las clases y objetos para formar estructuras más complejas.

Estos patrones facilitan la reutilización, flexibilizan la estructura del software y reducen el acoplamiento entre componentes. Su propósito principal es simplificar y mejorar la organización interna del código sin alterar su funcionalidad externa.

#### Adapter (Adaptador)

Adapter es un patrón de diseño estructural que permite la colaboración entre objetos con interfaces incompatibles.

##### Adapter - Problema

Imagina que estás creando una aplicación de monitoreo del mercado de valores. La aplicación descarga la información de bolsa desde varias fuentes en formato XML para presentarla al usuario con bonitos gráficos y diagramas.

En cierto momento, decides mejorar la aplicación integrando una inteligente biblioteca de análisis de una tercera persona. Pero hay una trampa: la biblioteca de análisis solo funciona con datos en formato JSON.

No puedes utilizar la biblioteca de análisis "tal cual" porque ésta espera los datos en un formato que es incompatible con tu aplicación. Podrías cambiar la biblioteca para que funcione con XML. Sin embargo, esto podría descomponer parte del código existente que depende de la biblioteca. Y, lo que es peor, podrías no tener siquiera acceso al código fuente de la biblioteca, lo que hace imposible esta solución.

##### Adapter - Solución

Puedes crear un **adaptador**. Se trata de un objeto especial que convierte la interfaz de un objeto, de forma que otro objeto pueda comprenderla.

Un adaptador envuelve uno de los objetos para esconder la complejidad de la conversión que tiene lugar tras bambalinas. El objeto envuelto ni siquiera es consciente de la existencia del adaptador. Por ejemplo, puedes envolver un objeto que opera con metros y kilómetros con un adaptador que convierte todos los datos al sistema anglosajón, es decir, pies y millas.

Los adaptadores no solo convierten datos a varios formatos, sino que también ayudan a objetos con distintas interfaces a colaborar. Funciona así:

1. El adaptador obtiene una interfaz compatible con uno de los objetos existentes.
2. Utilizando esta interfaz, el objeto existente puede invocar con seguridad los métodos del adaptador.
3. Al recibir una llamada, el adaptador pasa la solicitud al segundo objeto, pero en un formato y orden que ese segundo objeto espera.

En ocasiones se puede incluso crear un adaptador de dos direcciones que pueda convertir las llamadas en ambos sentidos.

Regresemos a nuestra aplicación del mercado de valores. Para resolver el dilema de los formatos incompatibles, puedes crear adaptadores de XML a JSON para cada clase de la biblioteca de análisis con la que trabaje tu código directamente. Después ajustas tu código para que se comunique con la biblioteca únicamente a través de estos adaptadores. Cuando un adaptador recibe una llamada, traduce los datos XML entrantes a una estructura JSON y pasa la llamada a los métodos adecuados de un objeto de análisis envuelto.

**Analogía en el mundo real:**

Cuando viajas de Europa a Estados Unidos por primera vez, puede ser que te lleves una sorpresa cuanto intentes cargar tu computadora portátil. Los tipos de enchufe son diferentes en cada país, por lo que un enchufe español no sirve en Estados Unidos. El problema puede solucionarse utilizando un adaptador que incluya el enchufe americano y el europeo.

##### Adapter - Estructura

1. **La clase Cliente** contiene la lógica de negocio existente del programa.

2. **La Interfaz con el Cliente** describe un protocolo que otras clases deben seguir para poder colaborar con el código cliente.

3. **Servicio** es alguna clase útil (normalmente de una tercera parte o heredada). El cliente no puede utilizar directamente esta clase porque tiene una interfaz incompatible.

4. **La clase Adaptadora** es capaz de trabajar tanto con la clase cliente como con la clase de servicio: implementa la interfaz con el cliente, mientras envuelve el objeto de la clase de servicio. La clase adaptadora recibe llamadas del cliente a través de la interfaz de cliente y las traduce en llamadas al objeto envuelto de la clase de servicio, pero en un formato que pueda comprender.

5. El código cliente no se acopla a la clase adaptadora concreta siempre y cuando funcione con la clase adaptadora a través de la interfaz con el cliente. Gracias a esto, puedes introducir nuevos tipos de adaptadores en el programa sin descomponer el código cliente existente. Esto puede resultar útil cuando la interfaz de la clase de servicio se cambia o sustituye, ya que puedes crear una nueva clase adaptadora sin cambiar el código cliente.

##### Adapter - ¿Cuándo se puede aplicar?

✓ Utiliza la clase adaptadora cuando quieras usar una clase existente, pero cuya interfaz no sea compatible con el resto del código.

✓ Utiliza el patrón cuando quieras reutilizar varias subclases existentes que carezcan de alguna funcionalidad común que no pueda añadirse a la superclase.

**Ventajas:**

✓ Permite la integración de clases existentes sin modificarlas.

✓ Promueve la reutilización de código heredado o de terceros.

#### Bridge (Puente)

Bridge es un patrón de diseño estructural que te permite dividir una clase grande, o un grupo de clases estrechamente relacionadas, en dos jerarquías separadas (abstracción e implementación) que pueden desarrollarse independientemente la una de la otra.

##### Bridge - Problema

¿Abstracción? ¿Implementación? ¿Asusta? Veamos un ejemplo sencillo.

Digamos que tienes una clase geométrica `Forma` con un par de subclases: `Círculo` y `Cuadrado`. Deseas extender esta jerarquía de clase para que incorpore colores, por lo que planeas crear las subclases de forma `Rojo` y `Azul`. Sin embargo, como ya tienes dos subclases, tienes que crear cuatro combinaciones de clase, como `CírculoAzul` y `CuadradoRojo`.

El número de combinaciones de clase crece en progresión geométrica. Añadir nuevos tipos de forma y color a la jerarquía hará que ésta crezca exponencialmente. Por ejemplo, para añadir una forma de triángulo deberás introducir dos subclases, una para cada color. Y, después, para añadir un nuevo color habrá que crear tres subclases, una para cada tipo de forma. Cuanto más avancemos, peor será.

##### Bridge - Solución

Este problema se presenta porque intentamos extender las clases de forma en dos dimensiones independientes: por forma y por color. Es un problema muy habitual en la herencia de clases.

El patrón Bridge intenta resolver este problema pasando de la herencia a la composición del objeto. Esto quiere decir que se extrae una de las dimensiones a una jerarquía de clases separada, de modo que las clases originales referencian un objeto de la nueva jerarquía, en lugar de tener todo su estado y sus funcionalidades dentro de una clase.

> **Puedes evitar la explosión de una jerarquía de clase transformándola en varias jerarquías relacionadas.**

Con esta solución, podemos extraer el código relacionado con el color y colocarlo dentro de su propia clase, con dos subclases: `Rojo` y `Azul`. La clase `Forma` obtiene entonces un campo de referencia que apunta a uno de los objetos de color. Ahora la forma puede delegar cualquier trabajo relacionado con el color al objeto de color vinculado. Esa referencia actuará como un **puente** entre las clases `Forma` y `Color`. En adelante, añadir nuevos colores no exigirá cambiar la jerarquía de forma y viceversa.

##### Bridge - Estructura

1. **La Abstracción** ofrece lógica de control de alto nivel. Depende de que el objeto de la implementación haga el trabajo de bajo nivel.

2. **La Implementación** declara la interfaz común a todas las implementaciones concretas. Una abstracción sólo se puede comunicar con un objeto de implementación a través de los métodos que se declaren aquí. La abstracción puede enumerar los mismos métodos que la implementación, pero normalmente la abstracción declara funcionalidades complejas que dependen de una amplia variedad de operaciones primitivas declaradas por la implementación.

3. **Las Implementaciones Concretas** contienen código específico de plataforma.

4. **Las Abstracciones Refinadas** proporcionan variantes de lógica de control. Como sus padres, trabajan con distintas implementaciones a través de la interfaz general de implementación.

5. Normalmente, **el Cliente** sólo está interesado en trabajar con la abstracción. No obstante, el cliente tiene que vincular el objeto de la abstracción con uno de los objetos de la implementación.

##### Bridge - ¿Cuándo se puede aplicar?

✓ Utiliza el patrón Bridge cuando quieras dividir y organizar una clase monolítica que tenga muchas variantes de una sola funcionalidad (por ejemplo, si la clase puede trabajar con diversos servidores de bases de datos).

✓ Utiliza el patrón Bridge cuando necesites poder cambiar implementaciones durante el tiempo de ejecución.

✓ Cuando quiera crear clases y aplicaciones independientes de plataforma.

---

### Contenido a desarrollar

*Este contenido será ampliado próximamente con más material de la materia.*

</div>
